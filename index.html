<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Obituary Scanner</title>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-dark: #0f172a; --bg-medium: #1e293b; --bg-light: #334155;
            --accent-blue: #3b82f6; --accent-green: #10b981; --accent-orange: #f59e0b; --accent-red: #ef4444;
            --text-primary: #f1f5f9; --text-secondary: #94a3b8; --border: #475569;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #1a2332 100%);
            color: var(--text-primary);
            min-height: 100vh;
        }

        .container { max-width: 1800px; margin: 0 auto; padding: 20px; }

        header {
            text-align: center; padding: 30px 20px;
            background: linear-gradient(135deg, var(--bg-medium) 0%, var(--bg-light) 100%);
            border-radius: 16px; margin-bottom: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 2.5rem; margin-bottom: 10px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }

        .upload-section {
            background: var(--bg-medium); border-radius: 16px; padding: 40px; text-align: center;
            margin-bottom: 30px; border: 2px dashed var(--border); transition: all 0.3s ease;
        }
        .upload-section:hover { border-color: var(--accent-blue); transform: translateY(-2px); }
        .upload-section.dragover { border-color: var(--accent-green); background: var(--bg-light); }

        input[type="file"] { display: none; }

        .btn {
            padding: 14px 32px; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600;
            cursor: pointer; transition: all 0.3s ease; display: inline-flex; align-items: center;
            gap: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); }
        .btn-primary { background: linear-gradient(135deg, var(--accent-blue), #2563eb); color: white; }
        .btn-success { background: var(--accent-green); color: white; }
        .btn-danger { background: var(--accent-red); color: white; }
        .btn-secondary { background: var(--bg-light); color: var(--text-primary); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }

        .scan-row {
            background: var(--bg-medium); border-radius: 12px; padding: 20px;
            margin-bottom: 20px; border: 1px solid var(--border);
        }

        .scan-row-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border);
        }

        .scan-row-content { display: flex; gap: 20px; }

        .scan-original {
            flex: 0 0 400px; background: var(--bg-light);
            border-radius: 8px; padding: 12px;
        }
        .scan-original img {
            width: 100%; height: auto; border-radius: 4px; cursor: pointer;
        }

        .scan-splits {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
            align-content: start;
        }

        .split-card {
            background: var(--bg-light); border-radius: 8px; padding: 10px;
            text-align: center; border: 2px solid transparent; transition: all 0.2s ease;
            position: relative;
        }
        .split-card:hover { border-color: var(--accent-blue); transform: scale(1.02); }

        .delete-split-btn {
            position: absolute; top: 5px; right: 5px; background: var(--accent-red);
            color: white; border: none; border-radius: 50%; width: 28px; height: 28px;
            cursor: pointer; font-size: 16px; opacity: 0; transition: opacity 0.2s; z-index: 10;
        }
        .split-card:hover .delete-split-btn { opacity: 1; }

        .split-card img {
            width: 100%; height: 180px; object-fit: contain;
            border-radius: 4px; margin-bottom: 8px;
        }
        .split-card-label { font-size: 0.85rem; color: var(--text-secondary); }

        .spinner {
            border: 3px solid var(--bg-light); border-top: 3px solid var(--accent-blue);
            border-radius: 50%; width: 30px; height: 30px;
            animation: spin 1s linear infinite; margin: 10px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .hidden { display: none !important; }

        .status-message {
            text-align: center; padding: 16px; margin-bottom: 20px;
            border-radius: 8px; font-weight: 500;
        }
        .status-message.info { background: rgba(59, 130, 246, 0.1); border: 1px solid var(--accent-blue); color: var(--accent-blue); }
        .status-message.success { background: rgba(16, 185, 129, 0.1); border: 1px solid var(--accent-green); color: var(--accent-green); }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìÑ Obituary Scanner</h1>
            <p style="color: var(--text-secondary); margin-top: 10px;">Parallel Processing Enabled (Fast Rotation Detection)</p>
        </header>

        <div id="uploadSection">
            <div class="upload-section" id="dropZone">
                <h2>üìÅ Upload Scanned Pages</h2>
                <p style="margin: 20px 0; color: var(--text-secondary);">Drag and drop files here, or click to browse</p>
                <input type="file" id="fileInput" accept="image/*" multiple />
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()"><span>üì∑</span> Select Images</button>
                    <button class="btn btn-secondary" onclick="clearAll()" id="clearAllTopBtn" style="display: none;">üóë Clear All</button>
                </div>
            </div>

            <div id="statusMessage"></div>
            <div id="scanRowsContainer"></div>

            <div class="controls hidden" id="verifyControls">
                <button class="btn btn-danger" onclick="clearAll()">üóë Clear All</button>
                <button class="btn btn-success">‚û°Ô∏è Next</button>
            </div>
        </div>
    </div>

    <script>
        let scannedPages = [];
        let scheduler = null;
        const WORKER_COUNT = 4;

        // Optimized: Init a pool of workers instead of just one
        async function getScheduler() {
            if (!scheduler) {
                showStatus('üöÄ Warming up processors...', 'info');
                scheduler = Tesseract.createScheduler();
                for (let i = 0; i < WORKER_COUNT; i++) {
                    const worker = await Tesseract.createWorker('eng');
                    // OSD mode is designed for ultra-fast rotation/orientation detection
                    await worker.setParameters({ tessedit_pageseg_mode: Tesseract.PSM.OSD });
                    scheduler.addWorker(worker);
                }
            }
            return scheduler;
        }

        const fileInput = document.getElementById('fileInput');
        fileInput.addEventListener('change', e => handleFiles(e.target.files));

        async function handleFiles(files) {
            const fileList = Array.from(files);
            if (fileList.length === 0) return;

            const activeScheduler = await getScheduler();
            showStatus(`üìÑ Processing ${fileList.length} page(s)...`, 'info');

            for (let i = 0; i < fileList.length; i++) {
                const file = fileList[i];
                const rowId = `row-${Date.now()}-${i}`;
                const imageData = await loadImageFile(file);

                addScanRow(rowId, imageData.dataUrl, file.name);
                
                // Process the page
                const splits = await findCardsParallel(imageData.canvas, activeScheduler);
                
                scannedPages.push({ filename: file.name, splits });
                displaySplits(rowId, splits);
            }

            showStatus(`‚úì Done! All obituaries oriented.`, 'success');
            document.getElementById('verifyControls').classList.remove('hidden');
            document.getElementById('clearAllTopBtn').style.display = 'inline-flex';
        }

        async function findCardsParallel(sourceCanvas, activeScheduler) {
            const { width, height } = sourceCanvas;
            const ctx = sourceCanvas.getContext('2d');
            
            // --- CV PRE-PROCESSING (Standard Grayscale/Blur/Threshold) ---
            const data = ctx.getImageData(0, 0, width, height).data;
            const gray = new Uint8ClampedArray(width * height);
            for (let i = 0; i < data.length; i += 4) {
                gray[i/4] = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
            }
            const blurred = gaussianBlur(gray, width, height, 15);
            const binary = new Uint8ClampedArray(width * height);
            for (let i = 0; i < blurred.length; i++) {
                binary[i] = (255 - blurred[i]) > 25 ? 255 : 0;
            }

            const contours = findConnectedComponents(binary, width, height);
            const boxes = filterAndSortBoxes(contours, width, height);
            
            if (boxes.length === 0) return [];

            // --- OPTIMIZED PARALLEL ROTATION DETECTION ---
            const processingPromises = boxes.map(async (box) => {
                // 1. Create a quick preview crop for detection
                const pad = 100;
                const tx = Math.max(0, box.x - pad), ty = Math.max(0, box.y - pad);
                const tw = Math.min(width - tx, box.w + 2 * pad), th = Math.min(height - ty, box.h + 2 * pad);
                
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = tw; tempCanvas.height = th;
                tempCanvas.getContext('2d').drawImage(sourceCanvas, tx, ty, tw, th, 0, 0, tw, th);

                // 2. High-speed OSD check (one pass, no loop)
                let rotationAngle = 0;
                try {
                    const { data } = await activeScheduler.addJob('detect', tempCanvas);
                    rotationAngle = (360 - data.orientation_degrees) % 360;
                } catch (e) { console.warn("Rotation detection failed"); }

                // 3. Final Crop with expansion logic
                const topExp = 200; const sidePad = 40;
                let fx, fy, fw, fh;

                if (rotationAngle === 0) {
                    fx = Math.max(0, box.x - sidePad); fy = Math.max(0, box.y - topExp);
                    fw = Math.min(width - fx, box.w + 2 * sidePad); fh = Math.min(height - fy, box.h + topExp + sidePad);
                } else if (rotationAngle === 90) {
                    fx = Math.max(0, box.x - topExp); fy = Math.max(0, box.y - sidePad);
                    fw = Math.min(width - fx, box.w + topExp + sidePad); fh = Math.min(height - fy, box.h + 2 * sidePad);
                } else if (rotationAngle === 180) {
                    fx = Math.max(0, box.x - sidePad); fy = Math.max(0, box.y - sidePad);
                    fw = Math.min(width - fx, box.w + 2 * sidePad); fh = Math.min(height - fy, box.h + topExp + sidePad);
                } else { // 270
                    fx = Math.max(0, box.x - sidePad); fy = Math.max(0, box.y - sidePad);
                    fw = Math.min(width - fx, box.w + topExp + sidePad); fh = Math.min(height - fy, box.h + 2 * sidePad);
                }

                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = fw; finalCanvas.height = fh;
                finalCanvas.getContext('2d').drawImage(sourceCanvas, fx, fy, fw, fh, 0, 0, fw, fh);

                let rotated = finalCanvas;
                if (rotationAngle !== 0) rotated = rotateCanvas(finalCanvas, rotationAngle);

                return { dataUrl: rotated.toDataURL('image/jpeg', 0.8) };
            });

            return await Promise.all(processingPromises);
        }

        // --- HELPERS ---
        function rotateCanvas(canvas, degrees) {
            const rot = document.createElement('canvas');
            const ctx = rot.getContext('2d');
            if (degrees === 90 || degrees === 270) {
                rot.width = canvas.height; rot.height = canvas.width;
            } else {
                rot.width = canvas.width; rot.height = canvas.height;
            }
            ctx.translate(rot.width / 2, rot.height / 2);
            ctx.rotate((degrees * Math.PI) / 180);
            ctx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
            return rot;
        }

        async function loadImageFile(file) {
            return new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => {
                    const img = new Image();
                    img.onload = () => {
                        const can = document.createElement('canvas');
                        can.width = img.width; can.height = img.height;
                        can.getContext('2d').drawImage(img, 0, 0);
                        resolve({ dataUrl: e.target.result, canvas: can });
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        function addScanRow(id, url, name) {
            const row = document.createElement('div');
            row.className = 'scan-row';
            row.id = id;
            row.innerHTML = `
                <div class="scan-row-header"><h3>${name}</h3></div>
                <div class="scan-row-content">
                    <div class="scan-original"><img src="${url}"></div>
                    <div class="scan-splits" id="${id}-splits"><div class="spinner"></div></div>
                </div>`;
            document.getElementById('scanRowsContainer').appendChild(row);
        }

        function displaySplits(id, splits) {
            const container = document.getElementById(`${id}-splits`);
            container.innerHTML = '';
            splits.forEach((s, i) => {
                const card = document.createElement('div');
                card.className = 'split-card';
                card.innerHTML = `<img src="${s.dataUrl}"><div class="split-card-label">Obituary ${i+1}</div>`;
                container.appendChild(card);
            });
        }

        function showStatus(msg, type) {
            const el = document.getElementById('statusMessage');
            el.textContent = msg; el.className = `status-message ${type}`;
        }

        function clearAll() {
            document.getElementById('scanRowsContainer').innerHTML = '';
            document.getElementById('verifyControls').classList.add('hidden');
            scannedPages = [];
        }

        // --- CV ALGORITHMS (Minimal Implementations) ---
        function gaussianBlur(gray, w, h, r) {
            const kernel = []; const sigma = r / 3; let sum = 0;
            for (let i = -r; i <= r; i++) {
                const v = Math.exp(-(i * i) / (2 * sigma * sigma));
                kernel.push(v); sum += v;
            }
            const norm = kernel.map(v => v / sum);
            const temp = new Uint8ClampedArray(w * h);
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let v = 0;
                    for (let k = -r; k <= r; k++) {
                        const nx = Math.min(w - 1, Math.max(0, x + k));
                        v += gray[y * w + nx] * norm[k + r];
                    }
                    temp[y * w + x] = v;
                }
            }
            const out = new Uint8ClampedArray(w * h);
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let v = 0;
                    for (let k = -r; k <= r; k++) {
                        const ny = Math.min(h - 1, Math.max(0, y + k));
                        v += temp[ny * w + x] * norm[k + r];
                    }
                    out[y * w + x] = v;
                }
            }
            return out;
        }

        function findConnectedComponents(binary, w, h) {
            const labels = new Int32Array(w * h).fill(0);
            let nextLabel = 1; const comps = [];
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (binary[y * w + x] && labels[y * w + x] === 0) {
                        let minX = x, maxX = x, minY = y, maxY = y, area = 0;
                        const stack = [[x, y]]; labels[y * w + x] = nextLabel;
                        while (stack.length > 0) {
                            const [cx, cy] = stack.pop(); area++;
                            minX = Math.min(minX, cx); maxX = Math.max(maxX, cx);
                            minY = Math.min(minY, cy); maxY = Math.max(maxY, cy);
                            [[cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]].forEach(([nx, ny]) => {
                                if (nx >= 0 && nx < w && ny >= 0 && ny < h && binary[ny * w + nx] && labels[ny * w + nx] === 0) {
                                    labels[ny * w + nx] = nextLabel; stack.push([nx, ny]);
                                }
                            });
                        }
                        comps.push({ x: minX, y: minY, w: maxX - minX, h: maxY - minY, area });
                        nextLabel++;
                    }
                }
            }
            return comps;
        }

        function filterAndSortBoxes(boxes, w, h) {
            return boxes.filter(b => (b.area / (w * h)) > 0.005 && b.w > 100 && b.h > 100).sort((a, b) => a.y - b.y);
        }
    </script>
</body>
</html>
