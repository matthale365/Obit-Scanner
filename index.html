<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Obituary Scanner</title>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-dark: #0f172a; --bg-medium: #1e293b; --bg-light: #334155;
            --accent-blue: #3b82f6; --accent-green: #10b981; --accent-orange: #f59e0b; --accent-red: #ef4444;
            --text-primary: #f1f5f9; --text-secondary: #94a3b8; --border: #475569;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #1a2332 100%);
            color: var(--text-primary);
            min-height: 100vh;
        }

        .container { max-width: 1800px; margin: 0 auto; padding: 20px; }
        
        header {
            text-align: center; padding: 30px 20px;
            background: linear-gradient(135deg, var(--bg-medium) 0%, var(--bg-light) 100%);
            border-radius: 16px; margin-bottom: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 2.5rem; margin-bottom: 10px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }

        .familysearch-login {
            margin-top: 15px;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: inline-block;
        }

        .familysearch-login.logged-in {
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid var(--accent-green);
        }

        .fs-matches {
            margin-top: 20px;
            padding: 15px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 8px;
            border: 1px solid var(--accent-blue);
        }

        .fs-match-item {
            background: var(--bg-light);
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border);
        }

        .fs-match-info {
            flex: 1;
        }

        .fs-match-name {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 4px;
        }

        .fs-match-details {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .fs-match-actions {
            display: flex;
            gap: 8px;
        }

        .upload-section {
            background: var(--bg-medium); border-radius: 16px; padding: 40px; text-align: center;
            margin-bottom: 30px; border: 2px dashed var(--border); transition: all 0.3s ease;
        }
        .upload-section:hover { border-color: var(--accent-blue); transform: translateY(-2px); }
        .upload-section.dragover { border-color: var(--accent-green); background: var(--bg-light); }

        input[type="file"] { display: none; }

        .btn {
            padding: 14px 32px; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600;
            cursor: pointer; transition: all 0.3s ease; display: inline-flex; align-items: center;
            gap: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); }
        .btn-primary { background: linear-gradient(135deg, var(--accent-blue), #2563eb); color: white; }
        .btn-success { background: var(--accent-green); color: white; }
        .btn-danger { background: var(--accent-red); color: white; }
        .btn-secondary { background: var(--bg-light); color: var(--text-primary); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }

        .scan-row {
            background: var(--bg-medium); border-radius: 12px; padding: 20px;
            margin-bottom: 20px; border: 1px solid var(--border);
        }

        .scan-row-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border);
        }

        .scan-row-content { display: flex; gap: 20px; }

        .scan-original {
            flex: 0 0 400px; background: var(--bg-light);
            border-radius: 8px; padding: 12px;
        }
        .scan-original img {
            width: 100%; height: auto; border-radius: 4px; cursor: pointer;
        }

        .scan-splits {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
            align-content: start;
        }

        .split-card {
            background: var(--bg-light); border-radius: 8px; padding: 10px;
            text-align: center; border: 2px solid transparent; transition: all 0.2s ease;
            position: relative;
        }
        .split-card:hover { border-color: var(--accent-blue); transform: scale(1.02); }
        .split-card:hover .delete-split-btn { opacity: 1; }
        
        .delete-split-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: var(--accent-red);
            color: white;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        .delete-split-btn:hover {
            background: #dc2626;
        }
        
        .split-card img {
            width: 100%; height: 180px; object-fit: contain;
            border-radius: 4px; margin-bottom: 8px;
        }
        .split-card-label { font-size: 0.85rem; color: var(--text-secondary); }

        .scan-row-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        /* Manual selection modal */
        .selection-canvas-container {
            position: relative;
            display: inline-block;
            max-width: 90vw;
            max-height: 70vh;
            overflow: auto;
            background: var(--bg-dark);
            border-radius: 8px;
        }

        .selection-box {
            position: absolute;
            border: 3px solid var(--accent-blue);
            background: rgba(59, 130, 246, 0.2);
            cursor: move;
            min-width: 50px;
            min-height: 50px;
        }

        .selection-box-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--accent-blue);
            border: 2px solid white;
        }
        .handle-nw { top: -6px; left: -6px; cursor: nw-resize; }
        .handle-ne { top: -6px; right: -6px; cursor: ne-resize; }
        .handle-sw { bottom: -6px; left: -6px; cursor: sw-resize; }
        .handle-se { bottom: -6px; right: -6px; cursor: se-resize; }

        .processing-indicator { text-align: center; padding: 20px; color: var(--text-secondary); }

        .spinner {
            border: 3px solid var(--bg-light); border-top: 3px solid var(--accent-blue);
            border-radius: 50%; width: 30px; height: 30px;
            animation: spin 1s linear infinite; margin: 10px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .controls { display: flex; gap: 12px; justify-content: center; margin: 30px 0; }
        .hidden { display: none !important; }

        .status-message {
            text-align: center; padding: 16px; margin-bottom: 20px;
            border-radius: 8px; font-weight: 500;
        }
        .status-message.info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid var(--accent-blue);
            color: var(--accent-blue);
        }
        .status-message.success {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid var(--accent-green);
            color: var(--accent-green);
        }

        .modal {
            display: none; position: fixed; z-index: 1000;
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
        }
        .modal.active { display: flex; align-items: center; justify-content: center; }

        .modal-content {
            position: relative; max-width: 90vw; max-height: 90vh;
            display: flex; flex-direction: column;
        }

        .modal-controls {
            display: flex; gap: 12px; margin-bottom: 12px; justify-content: center;
        }

        .modal-image-container {
            flex: 1; overflow: auto; background: var(--bg-medium);
            border-radius: 8px; padding: 20px; text-align: center;
            cursor: grab;
            user-select: none; /* Prevent text selection while dragging */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            /* Hide scrollbars */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        .modal-image-container::-webkit-scrollbar {
            display: none; /* Chrome/Safari */
        }
        .modal-image-container.dragging {
            cursor: grabbing;
        }

        .modal-image {
            max-width: none; /* Allow dragging past edges */
            height: auto; 
            transform-origin: center center;
            pointer-events: none; /* Prevent image dragging */
        }

        .close-modal {
            position: absolute; top: -40px; right: 0;
            font-size: 2rem; color: white; cursor: pointer;
        }

        .results-list { display: flex; flex-direction: column; gap: 16px; margin-bottom: 30px; }

        .result-item {
            background: var(--bg-medium); border-radius: 12px; padding: 20px;
            display: flex; gap: 20px; align-items: center; cursor: pointer;
            transition: all 0.3s ease; border: 1px solid var(--border);
        }
        .result-item:hover { background: var(--bg-light); transform: translateX(8px); }

        .result-thumbnail {
            width: 120px; height: 160px; border-radius: 8px;
            background: var(--bg-light); flex-shrink: 0; overflow: hidden;
            display: flex; align-items: center; justify-content: center;
        }
        .result-thumbnail img { max-width: 100%; max-height: 100%; object-fit: contain; }

        .result-info { flex: 1; }
        .result-name { font-size: 1.5rem; font-weight: 600; margin-bottom: 8px; }
        .result-dates { color: var(--text-secondary); font-size: 0.95rem; margin-bottom: 4px; }
        .result-source {
            color: var(--accent-blue); font-size: 0.85rem; cursor: pointer;
        }
        .result-source:hover { text-decoration: underline; }

        .detail-view {
            display: grid; grid-template-columns: 1fr 1fr 1fr;
            gap: 20px; margin-bottom: 30px;
        }
        @media (max-width: 1200px) { .detail-view { grid-template-columns: 1fr; } }

        .detail-panel {
            background: var(--bg-medium); border-radius: 12px; overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); border: 1px solid var(--border);
            display: flex; flex-direction: column;
        }

        .panel-header {
            padding: 16px 20px; font-weight: 600; font-size: 1.1rem;
            display: flex; align-items: center; gap: 10px;
        }
        .panel-header.blue { background: var(--accent-blue); }
        .panel-header.green { background: var(--accent-green); }
        .panel-header.orange { background: var(--accent-orange); }

        .panel-content {
            padding: 20px; overflow-y: auto; flex: 1; max-height: 600px;
            white-space: pre-wrap; word-wrap: break-word; line-height: 1.6;
        }
        .panel-content img {
            max-width: 100%; height: auto; border-radius: 8px; cursor: pointer;
        }

        .fact-item {
            margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid var(--border);
        }
        .fact-item:last-child { border-bottom: none; }

        .fact-label {
            font-size: 0.85rem; color: var(--text-secondary);
            text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px;
        }
        .fact-value { font-size: 1rem; color: var(--text-primary); }

        .navigation {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; padding: 16px 20px; background: var(--bg-medium);
            border-radius: 12px;
        }
        .nav-title { font-size: 1.2rem; font-weight: 600; }
        .nav-buttons { display: flex; gap: 12px; }

        .progress-section {
            background: var(--bg-medium); border-radius: 12px; padding: 40px;
            margin-bottom: 30px; text-align: center;
        }

        .progress-bar-container {
            width: 100%; max-width: 600px; height: 12px;
            background: var(--bg-light); border-radius: 12px; margin: 30px auto;
            overflow: hidden; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-green));
            border-radius: 12px; transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìÑ Obituary Scanner</h1>
            <p style="color: var(--text-secondary); margin-top: 10px;">Upload scans ‚Üí Verify splits ‚Üí Extract text</p>
            
            <div class="familysearch-login" id="fsLoginSection">
                <span id="fsStatus">Not connected to FamilySearch</span>
                <button class="btn btn-primary" onclick="loginToFamilySearch()" id="fsLoginBtn" style="margin-left: 12px; padding: 8px 16px; font-size: 0.9rem;">
                    üå≥ Connect FamilySearch
                </button>
                <button class="btn btn-secondary" onclick="logoutFromFamilySearch()" id="fsLogoutBtn" style="margin-left: 12px; padding: 8px 16px; font-size: 0.9rem; display: none;">
                    Disconnect
                </button>
            </div>
        </header>

        <div id="uploadSection">
            <div class="upload-section" id="dropZone">
                <h2>üìÅ Upload Scanned Pages</h2>
                <p style="margin: 20px 0; color: var(--text-secondary);">
                    Drag and drop files here, or click to browse
                </p>
                <input type="file" id="fileInput" accept="image/*" multiple />
                <div style="display: flex; gap: 12px; justify-content: center; align-items: center;">
                    <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                        <span>üì∑</span> Select Images
                    </button>
                    <button class="btn btn-secondary" onclick="clearAllScans()" id="clearAllTopBtn" style="display: none; padding: 10px 20px; font-size: 0.9rem; opacity: 0.7;">
                        üóë Clear All
                    </button>
                </div>
            </div>

            <div id="statusMessage"></div>
            <div id="scanRowsContainer"></div>

            <div class="controls hidden" id="verifyControls">
                <button class="btn btn-danger" onclick="clearAllScans()">üóë Clear All</button>
                <button class="btn btn-success" onclick="startExtraction()">üöÄ Extract Text from All Obituaries</button>
            </div>
        </div>

        <div id="processingSection" class="hidden">
            <div class="progress-section">
                <h2>üîç Extracting Text...</h2>
                <div class="spinner"></div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar" style="width: 0%"></div>
                </div>
                <p id="progressText" style="margin-top: 20px; color: var(--text-secondary);">Processing...</p>
            </div>
        </div>

        <div id="resultsSection" class="hidden">
            <div class="navigation">
                <div class="nav-title">‚úì Extracted Obituaries</div>
                <button class="btn btn-secondary" onclick="backToVerify()">‚Üê Back to Scans</button>
            </div>
            <div id="resultsList" class="results-list"></div>
        </div>

        <div id="detailSection" class="hidden">
            <div class="navigation">
                <div class="nav-title" id="detailTitle">Obituary Details</div>
                <div class="nav-buttons">
                    <button class="btn btn-secondary" onclick="showResultsList()">‚Üê Back to List</button>
                    <button class="btn btn-primary" onclick="previousCard()" id="prevBtn">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="nextCard()" id="nextBtn">Next ‚Üí</button>
                </div>
            </div>

            <div class="detail-view">
                <div class="detail-panel">
                    <div class="panel-header blue">
                        üì∑ Obituary Image
                        <button class="btn btn-secondary" onclick="showFullScan()" style="margin-left: auto; padding: 6px 12px; font-size: 0.85rem;">
                            üîç View Full Scan
                        </button>
                    </div>
                    <div class="panel-content">
                        <img id="detailImage" src="" alt="Obituary" onclick="showFullScan()" />
                    </div>
                </div>

                <div class="detail-panel">
                    <div class="panel-header green">üìù Full Text</div>
                    <div class="panel-content" id="detailText"></div>
                </div>

                <div class="detail-panel">
                    <div class="panel-header orange">üîç Key Facts</div>
                    <div class="panel-content" id="detailFacts"></div>
                </div>
            </div>

            <!-- FamilySearch Matches Section -->
            <div id="fsMatchesSection" class="hidden" style="margin-top: 20px;">
                <div class="fs-matches">
                    <h3 style="margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                        üå≥ FamilySearch Matches
                        <button class="btn btn-primary" onclick="searchFamilySearch()" id="fsSearchBtn" style="padding: 6px 12px; font-size: 0.85rem; margin-left: auto;">
                            üîç Search Again
                        </button>
                    </h3>
                    <div id="fsMatchesList"></div>
                </div>
            </div>
        </div>

        <div id="scanModal" class="modal">
            <div class="modal-content">
                <span class="close-modal" onclick="closeModal()">&times;</span>
                <div class="modal-controls">
                    <button class="btn btn-secondary" onclick="rotateModalImage()">‚ü≥ Rotate</button>
                    <button class="btn btn-secondary" onclick="zoomModalImage(1.2)">üîç+ Zoom In</button>
                    <button class="btn btn-secondary" onclick="zoomModalImage(0.8)">üîç- Zoom Out</button>
                    <button class="btn btn-secondary" onclick="resetModalImage()">‚Ü∫ Reset</button>
                </div>
                <div class="modal-image-container" id="modalImageContainer">
                    <img id="modalImage" class="modal-image" src="" alt="Full Scan" />
                </div>
            </div>
        </div>
    </div>

    <script>
        let scannedPages = [];
        let allObituaries = [];
        let currentDetailIndex = 0;
        let tesseractWorker = null;
        let modalRotation = 0;
        let modalZoom = 1;

        // FamilySearch API
        const FS_APP_KEY = 'YOUR_APP_KEY_HERE'; // You'll need to register at https://www.familysearch.org/developers/
        const FS_REDIRECT_URI = window.location.origin + window.location.pathname;
        let fsAccessToken = null;
        let fsCurrentMatches = [];

        // Initialize
        (function() {
            const fileInput = document.getElementById('fileInput');
            const dropZone = document.getElementById('dropZone');

            fileInput.addEventListener('change', handleFiles);
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                if (files.length > 0) handleFiles({ target: { files } });
            });
            document.getElementById('scanModal').addEventListener('click', function(e) {
                if (e.target === this) closeModal();
            });
        })();

        async function handleFiles(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            showStatus(`üìÑ Loading ${files.length} scan(s)...`, 'info');

            // STEP 1: Instantly show all scans first
            const pendingScans = [];
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const pageIndex = scannedPages.length + i;
                const rowId = `scan-row-${pageIndex}`;
                
                // Load image data
                const imageData = await loadImageFile(file);
                
                // Add row immediately with "Processing..." message
                addScanRow(rowId, imageData.dataUrl, file.name);
                showScanProcessing(rowId);
                
                // Store for batch processing
                pendingScans.push({
                    rowId,
                    pageIndex,
                    file,
                    imageData
                });
            }

            showStatus(`‚úì ${files.length} scan(s) loaded. Detecting obituaries...`, 'info');

            // STEP 2: Process all splits in batch
            for (const scan of pendingScans) {
                const splits = await findCards(scan.imageData.canvas, scan.pageIndex);
                
                // Auto-rotate each split
                for (let split of splits) {
                    await autoRotate(split);
                }

                // Store page data
                scannedPages.push({
                    originalImage: scan.imageData.dataUrl,
                    filename: scan.file.name,
                    splits: splits
                });

                // Display splits
                displaySplits(scan.rowId, splits);
            }

            showStatus(`‚úì All scans processed. Review the splits below.`, 'success');
            document.getElementById('verifyControls').classList.remove('hidden');
            document.getElementById('clearAllTopBtn').style.display = 'inline-flex';
        }

        async function loadImageFile(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        
                        resolve({
                            dataUrl: e.target.result,
                            canvas: canvas
                        });
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        function addScanRow(rowId, imageUrl, filename) {
            const container = document.getElementById('scanRowsContainer');
            const row = document.createElement('div');
            row.className = 'scan-row';
            row.id = rowId;
            row.innerHTML = `
                <div class="scan-row-header">
                    <h3 style="margin: 0;">${filename}</h3>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <span class="scan-status" style="color: var(--text-secondary);"></span>
                        <button class="btn btn-danger" onclick="deleteScan('${rowId}')" style="padding: 6px 12px; font-size: 0.85rem;">
                            üóë Delete Scan
                        </button>
                    </div>
                </div>
                <div class="scan-row-content">
                    <div class="scan-original">
                        <img src="${imageUrl}" alt="${filename}" onclick="viewFullScan('${imageUrl}')" title="Click to view full size" />
                    </div>
                    <div class="scan-splits" id="${rowId}-splits"></div>
                </div>
                <div class="scan-row-actions">
                    <button class="btn btn-secondary" onclick="addManualSelection('${rowId}')" style="padding: 8px 16px; font-size: 0.9rem;">
                        ‚ûï Add Missing Obituary
                    </button>
                </div>
            `;
            container.appendChild(row);
        }

        function showScanProcessing(rowId) {
            document.getElementById(`${rowId}-splits`).innerHTML = `
                <div class="processing-indicator"><div class="spinner"></div><p>Detecting obituaries...</p></div>
            `;
        }

        function displaySplits(rowId, splits) {
            const splitsContainer = document.getElementById(`${rowId}-splits`);
            splitsContainer.innerHTML = '';

            if (splits.length === 0) {
                splitsContainer.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">No obituaries detected</p>';
                return;
            }

            splits.forEach((split, index) => {
                const card = document.createElement('div');
                card.className = 'split-card';
                card.innerHTML = `
                    <button class="delete-split-btn" onclick="deleteSplit('${rowId}', ${index})" title="Delete this obituary">√ó</button>
                    <img src="${split.dataUrl}" alt="Obit ${index + 1}" onclick="viewFullScan('${split.dataUrl}')" style="cursor: pointer;" title="Click to enlarge" />
                    <div class="split-card-label">Obituary ${index + 1}</div>
                `;
                splitsContainer.appendChild(card);
            });

            const status = document.getElementById(rowId).querySelector('.scan-status');
            status.textContent = `‚úì Found ${splits.length} obituar${splits.length === 1 ? 'y' : 'ies'}`;
            status.style.color = 'var(--accent-green)';
        }

        async function findCards(sourceCanvas, pageIndex) {
            const ctx = sourceCanvas.getContext('2d');
            const width = sourceCanvas.width;
            const height = sourceCanvas.height;
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;

            console.log(`\n=== Processing Scan ${pageIndex + 1}: ${width}x${height} ===`);
            console.log('Using "Blurred Vision" technique\n');

            // Step 1: Grayscale
            console.log('Step 1: Converting to grayscale...');
            const gray = new Uint8ClampedArray(width * height);
            for (let i = 0; i < data.length; i += 4) {
                gray[i/4] = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
            }

            // Step 2: HEAVY Gaussian Blur (make letters disappear!)
            console.log('Step 2: Applying heavy Gaussian blur...');
            console.log('  (Blurring until individual letters disappear)');
            const blurred = gaussianBlur(gray, width, height, 25); // Large radius

            // Step 3: Invert (text becomes white, background becomes black)
            console.log('Step 3: Inverting image...');
            const inverted = new Uint8ClampedArray(width * height);
            for (let i = 0; i < blurred.length; i++) {
                inverted[i] = 255 - blurred[i];
            }

            // Step 4: Threshold (turn grey clouds into solid black blocks)
            console.log('Step 4: Thresholding...');
            const binary = new Uint8ClampedArray(width * height);
            const threshold = 30; // Low threshold - anything not pure white becomes black
            
            for (let i = 0; i < inverted.length; i++) {
                binary[i] = inverted[i] > threshold ? 255 : 0;
            }

            let whitePixels = 0;
            for (let i = 0; i < binary.length; i++) {
                if (binary[i] === 255) whitePixels++;
            }
            console.log(`  ${whitePixels} white pixels (${(whitePixels/binary.length*100).toFixed(1)}%)`);

            // Step 5: Light dilation to ensure blobs are solid
            console.log('\nStep 5: Light dilation to solidify blobs...');
            let morphed = binary.slice();
            for (let iter = 0; iter < 3; iter++) {
                morphed = morphDilate(morphed, width, height, 5);
            }

            // Step 6: Find contours (coastlines of black blobs)
            console.log('\nStep 6: Finding contours (blob coastlines)...');
            const contours = findConnectedComponents(morphed, width, height);
            console.log(`  Found ${contours.length} contours`);

            // Step 7: Get bounding boxes and filter
            console.log('\nStep 7: Calculating bounding boxes...');
            const boxes = filterAndSortBoxes(contours, width, height);

            if (boxes.length === 0) {
                console.log('No valid boxes found, returning full image');
                return [{
                    canvas: sourceCanvas,
                    dataUrl: sourceCanvas.toDataURL('image/jpeg', 0.95),
                    rotated: false,
                    sourcePageIndex: pageIndex
                }];
            }

            console.log(`\n‚úì Found ${boxes.length} obituaries`);

            // Step 8: Crop original image using bounding boxes
            console.log('\nStep 8: Cropping original image...');
            const cards = [];
            for (let i = 0; i < boxes.length; i++) {
                const box = boxes[i];
                const padding = 20;
                
                // Crop coordinates
                const sourceX = Math.max(0, box.x - padding);
                const sourceY = Math.max(0, box.y - padding);
                const sourceW = Math.min(width - sourceX, box.w + 2 * padding);
                const sourceH = Math.min(height - sourceY, box.h + 2 * padding);

                // Create new canvas for this crop
                const cardCanvas = document.createElement('canvas');
                cardCanvas.width = sourceW;
                cardCanvas.height = sourceH;
                const cardCtx = cardCanvas.getContext('2d');
                
                // Draw cropped region from ORIGINAL image
                cardCtx.drawImage(sourceCanvas, sourceX, sourceY, sourceW, sourceH, 0, 0, sourceW, sourceH);
                
                console.log(`  Obit ${i+1}: ${sourceW}x${sourceH} at (${sourceX}, ${sourceY})`);
                
                cards.push({
                    canvas: cardCanvas,
                    dataUrl: cardCanvas.toDataURL('image/jpeg', 0.95),
                    rotated: false,
                    sourcePageIndex: pageIndex
                });
            }

            return cards;
        }

        function gaussianBlur(gray, width, height, radius) {
            // Heavy Gaussian blur to make letters disappear
            console.log(`  Blur radius: ${radius}px`);
            
            // Create Gaussian kernel
            const kernel = [];
            const sigma = radius / 3;
            let sum = 0;
            
            for (let i = -radius; i <= radius; i++) {
                const value = Math.exp(-(i * i) / (2 * sigma * sigma));
                kernel.push(value);
                sum += value;
            }
            
            // Normalize kernel
            for (let i = 0; i < kernel.length; i++) {
                kernel[i] /= sum;
            }

            // Horizontal pass
            const temp = new Uint8ClampedArray(width * height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let value = 0;
                    
                    for (let k = -radius; k <= radius; k++) {
                        const nx = x + k;
                        if (nx >= 0 && nx < width) {
                            value += gray[y * width + nx] * kernel[k + radius];
                        }
                    }
                    
                    temp[y * width + x] = Math.round(value);
                }
            }

            // Vertical pass
            const output = new Uint8ClampedArray(width * height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let value = 0;
                    
                    for (let k = -radius; k <= radius; k++) {
                        const ny = y + k;
                        if (ny >= 0 && ny < height) {
                            value += temp[ny * width + x] * kernel[k + radius];
                        }
                    }
                    
                    output[y * width + x] = Math.round(value);
                }
            }

            return output;
        }

        function filterAndSortBoxes(contours, width, height) {
            const imageArea = width * height;
            const valid = [];

            for (const box of contours) {
                const areaPercent = (box.area / imageArea) * 100;
                const aspectRatio = Math.max(box.w, box.h) / Math.min(box.w, box.h);

                console.log(`  Box: ${box.w}x${box.h} at (${box.x},${box.y}) - ${areaPercent.toFixed(1)}%`);

                // Filter criteria
                if (box.w < 150 || box.h < 150) {
                    console.log(`    ‚úó Too small`);
                    continue;
                }

                if (areaPercent < 0.5) {
                    console.log(`    ‚úó Tiny area (${areaPercent.toFixed(2)}%)`);
                    continue;
                }

                if (areaPercent > 90) {
                    console.log(`    ‚úó Nearly full page`);
                    continue;
                }

                if (aspectRatio > 40) {
                    console.log(`    ‚úó Bad aspect ratio (${aspectRatio.toFixed(1)})`);
                    continue;
                }

                console.log(`    ‚úì VALID`);
                valid.push(box);
            }

            // Sort by position (top to bottom, left to right)
            valid.sort((a, b) => {
                const yDiff = a.y - b.y;
                if (Math.abs(yDiff) < height * 0.12) {
                    return a.x - b.x;
                }
                return yDiff;
            });

            return valid;
        }

        function findConnectedComponents(binary, width, height) {
            const visited = new Uint8ClampedArray(width * height);
            const components = [];

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (binary[y * width + x] === 255 && !visited[y * width + x]) {
                        const component = floodFillComponent(binary, visited, width, height, x, y);
                        if (component) components.push(component);
                    }
                }
            }

            return components;
        }

        function floodFillComponent(binary, visited, width, height, startX, startY) {
            const stack = [[startX, startY]];
            let minX = startX, maxX = startX, minY = startY, maxY = startY;
            let count = 0;

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                
                const idx = y * width + x;
                if (visited[idx] || binary[idx] !== 255) continue;

                visited[idx] = 1;
                count++;
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);

                stack.push([x+1, y], [x-1, y], [x, y+1], [x, y-1]);
            }

            return {
                x: minX,
                y: minY,
                w: maxX - minX + 1,
                h: maxY - minY + 1,
                area: (maxX - minX + 1) * (maxY - minY + 1),
                pixelCount: count
            };
        }

        function calculateOtsuThreshold(gray) {
            // Build histogram
            const histogram = new Array(256).fill(0);
            for (let i = 0; i < gray.length; i++) {
                histogram[gray[i]]++;
            }

            const total = gray.length;
            let sum = 0;
            for (let i = 0; i < 256; i++) {
                sum += i * histogram[i];
            }

            let sumB = 0, wB = 0, wF = 0;
            let maxVariance = 0;
            let threshold = 0;

            for (let t = 0; t < 256; t++) {
                wB += histogram[t];
                if (wB === 0) continue;
                
                wF = total - wB;
                if (wF === 0) break;

                sumB += t * histogram[t];
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;

                const variance = wB * wF * (mB - mF) * (mB - mF);

                if (variance > maxVariance) {
                    maxVariance = variance;
                    threshold = t;
                }
            }

            return threshold;
        }

        function scoreDetectionResult(regions, width, height) {
            if (regions.length === 0) return 0;

            let score = 0;

            // Prefer 3-6 obituaries (most common)
            if (regions.length >= 3 && regions.length <= 6) {
                score += 50;
            } else if (regions.length >= 2 && regions.length <= 8) {
                score += 30;
            } else {
                score += 10;
            }

            // Check size consistency
            const avgArea = regions.reduce((sum, r) => sum + r.area, 0) / regions.length;
            const areaVariance = regions.reduce((sum, r) => sum + Math.abs(r.area - avgArea), 0) / regions.length;
            const consistency = 1 - (areaVariance / avgArea);
            score += consistency * 30;

            // Prefer reasonable sizes
            const totalImageArea = width * height;
            const totalObitArea = regions.reduce((sum, r) => sum + r.area, 0);
            const coverage = totalObitArea / totalImageArea;
            
            if (coverage > 0.4 && coverage < 0.85) {
                score += 20; // Good coverage
            }

            return score;
        }

        function floodFillContour(binary, visited, width, height, startX, startY) {
            const stack = [[startX, startY]];
            let minX = startX, maxX = startX;
            let minY = startY, maxY = startY;
            let pixelCount = 0;

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const idx = y * width + x;

                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                if (visited[idx] || binary[idx] !== 255) continue;

                visited[idx] = 1;
                pixelCount++;
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);

                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            const w = maxX - minX + 1;
            const h = maxY - minY + 1;

            return {
                x: minX,
                y: minY,
                w: w,
                h: h,
                area: w * h,
                pixelCount: pixelCount
            };
        }

        function morphDilate(binary, width, height, kernelSize) {
            const result = new Uint8ClampedArray(width * height);
            const halfKernel = Math.floor(kernelSize / 2);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let maxVal = 0;
                    for (let ky = -halfKernel; ky <= halfKernel; ky++) {
                        for (let kx = -halfKernel; kx <= halfKernel; kx++) {
                            const ny = y + ky, nx = x + kx;
                            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                maxVal = Math.max(maxVal, binary[ny * width + nx]);
                            }
                        }
                    }
                    result[y * width + x] = maxVal;
                }
            }
            return result;
        }

        function morphErode(binary, width, height, kernelSize) {
            const result = new Uint8ClampedArray(width * height);
            const halfKernel = Math.floor(kernelSize / 2);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let minVal = 255;
                    for (let ky = -halfKernel; ky <= halfKernel; ky++) {
                        for (let kx = -halfKernel; kx <= halfKernel; kx++) {
                            const ny = y + ky, nx = x + kx;
                            if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                minVal = Math.min(minVal, binary[ny * width + nx]);
                            }
                        }
                    }
                    result[y * width + x] = minVal;
                }
            }
            return result;
        }

        async function autoRotate(card) {
            if (!tesseractWorker) tesseractWorker = await Tesseract.createWorker('eng');

            const sample = document.createElement('canvas');
            sample.width = sample.height = 300;
            const sctx = sample.getContext('2d');
            sctx.drawImage(card.canvas, (card.canvas.width - 300) / 2, (card.canvas.height - 300) / 2, 300, 300, 0, 0, 300, 300);

            let best = 0, bestConf = 0;
            for (let r = 0; r < 4; r++) {
                const rotated = rotateCanvas(sample, r * 90);
                try {
                    const result = await tesseractWorker.recognize(rotated);
                    if (result.data.confidence > bestConf) {
                        bestConf = result.data.confidence;
                        best = r;
                    }
                } catch (err) {}
            }

            if (best > 0) {
                card.canvas = rotateCanvas(card.canvas, best * 90);
                card.rotated = true;
            }
            card.dataUrl = card.canvas.toDataURL('image/jpeg', 0.95);
        }

        function rotateCanvas(canvas, degrees) {
            const nc = document.createElement('canvas');
            const ctx = nc.getContext('2d');
            if (degrees === 90 || degrees === 270) {
                nc.width = canvas.height;
                nc.height = canvas.width;
            } else {
                nc.width = canvas.width;
                nc.height = canvas.height;
            }
            ctx.translate(nc.width / 2, nc.height / 2);
            ctx.rotate((degrees * Math.PI) / 180);
            ctx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
            return nc;
        }

        async function startExtraction() {
            allObituaries = [];
            scannedPages.forEach(page => {
                page.splits.forEach(split => {
                    allObituaries.push({
                        image: split.dataUrl,
                        canvas: split.canvas,
                        sourcePageIndex: split.sourcePageIndex,
                        sourceFilename: page.filename,
                        sourceImage: page.originalImage,
                        text: null,
                        facts: null
                    });
                });
            });

            if (allObituaries.length === 0) { alert('No obituaries to process!'); return; }

            document.getElementById('uploadSection').classList.add('hidden');
            document.getElementById('processingSection').classList.remove('hidden');

            if (!tesseractWorker) tesseractWorker = await Tesseract.createWorker('eng');

            for (let i = 0; i < allObituaries.length; i++) {
                updateProgress((i / allObituaries.length) * 70, `OCR: ${i + 1}/${allObituaries.length}`);
                const result = await tesseractWorker.recognize(allObituaries[i].canvas);
                allObituaries[i].text = cleanText(result.data.text);
            }

            updateProgress(75, 'Extracting key information...');
            for (let i = 0; i < allObituaries.length; i++) {
                allObituaries[i].facts = extractFacts(allObituaries[i].text);
                updateProgress(75 + ((i + 1) / allObituaries.length) * 25, `Extracting: ${i + 1}/${allObituaries.length}`);
            }

            updateProgress(100, 'Complete!');
            setTimeout(() => {
                document.getElementById('processingSection').classList.add('hidden');
                showResultsList();
            }, 1000);
        }

        function cleanText(text) {
            if (!text) return '';
            text = text.replace(/ {2,}/g, ' ').replace(/\|/g, 'I');
            const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
            return lines.join(' ').replace(/ +/g, ' ').trim();
        }

        function extractFacts(text) {
            if (!text) return {
                name: 'Unknown', maiden_name: 'Not mentioned', birth_date: 'Not mentioned',
                death_date: 'Not mentioned', spouse: 'Not mentioned', children: 'Not mentioned',
                other_family: 'Not mentioned', location: 'Not mentioned'
            };

            const facts = {
                name: 'Unknown', 
                maiden_name: 'Not mentioned', 
                birth_date: 'Not mentioned',
                death_date: 'Not mentioned', 
                spouse: 'Not mentioned', 
                children: 'Not mentioned',
                other_family: 'Not mentioned', 
                location: 'Not mentioned'
            };

            // Clean text for better matching
            const cleanedText = text.replace(/\s+/g, ' ').trim();
            
            // Split into lines for position-based extraction
            const lines = text.split('\n').map(l => l.trim()).filter(Boolean);

            // 1. EXTRACT NAME - PRIORITY: First few lines (where header typically is)
            let nameFound = false;
            
            // Check first 3 lines for name in "LASTNAME, Firstname" or "Firstname Lastname" format
            for (let i = 0; i < Math.min(3, lines.length); i++) {
                const line = lines[i];
                
                // Skip lines that are clearly dates or too short
                if (line.length < 5 || /^\d{1,2}[\/\-]/.test(line) || /^(?:January|February|March|April|May|June|July|August|September|October|November|December)/i.test(line)) {
                    continue;
                }
                
                // Pattern 1: "LASTNAME, Firstname Middle" (most common in obituary headers)
                const lastFirstMatch = line.match(/^([A-Z][A-Z\s]+),\s+([A-Z][a-z]+(?:\s+[A-Z][a-z\.]*)*)/);
                if (lastFirstMatch) {
                    const lastName = lastFirstMatch[1].split(/\s+/).map(w => 
                        w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
                    ).join(' ');
                    facts.name = `${lastFirstMatch[2]} ${lastName}`;
                    nameFound = true;
                    break;
                }
                
                // Pattern 2: "Firstname Middle Lastname" at start (title case)
                const firstLastMatch = line.match(/^([A-Z][a-z]+(?:\s+[A-Z][a-z\.]*)*\s+[A-Z][a-z]+)$/);
                if (firstLastMatch && !line.includes(',')) {
                    // Make sure it's not a date or common phrase
                    const lowerLine = line.toLowerCase();
                    if (!lowerLine.includes('obituary') && !lowerLine.includes('memory') && 
                        !lowerLine.includes('service') && !lowerLine.includes('funeral')) {
                        facts.name = firstLastMatch[1];
                        nameFound = true;
                        break;
                    }
                }
                
                // Pattern 3: All caps name (common in headers)
                const allCapsMatch = line.match(/^([A-Z][A-Z\s]{5,50})$/);
                if (allCapsMatch && !allCapsMatch[1].includes('DEATH') && !allCapsMatch[1].includes('OBITUAR')) {
                    // Convert to title case
                    facts.name = allCapsMatch[1].split(/\s+/).map(w => 
                        w.charAt(0) + w.slice(1).toLowerCase()
                    ).join(' ');
                    nameFound = true;
                    break;
                }
            }

            // Fallback: If name not found in first lines, try body text patterns
            if (!nameFound) {
                const namePatterns = [
                    // After common headers
                    /(?:obituary|memory|passing|death)\s+(?:of|for)?\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]*\.?)?\s+[A-Z][a-z]+)/i,
                    // Before dates or age
                    /([A-Z][a-z]+(?:\s+[A-Z][a-z]*\.?)?\s+[A-Z][a-z]+),?\s+(?:age|aged|\d)/i,
                    // At start of text
                    /^([A-Z][a-z]+(?:\s+[A-Z][a-z]*\.?)?\s+[A-Z][a-z]+)/
                ];

                for (const pattern of namePatterns) {
                    const match = cleanedText.match(pattern);
                    if (match) {
                        facts.name = match[1];
                        nameFound = true;
                        break;
                    }
                }
            }

            // 2. EXTRACT MAIDEN NAME
            const maidenPatterns = [
                /\((?:n[e√©]e|maiden\s+name|born)\s+([A-Z][a-z]+)\)/i,
                /n[e√©]e\s+([A-Z][a-z]+)/i,
                /maiden\s+name\s+([A-Z][a-z]+)/i
            ];

            for (const pattern of maidenPatterns) {
                const match = cleanedText.match(pattern);
                if (match) {
                    facts.maiden_name = match[1];
                    break;
                }
            }

            // 3. EXTRACT DATES
            // Look for dates in various formats - but exclude from first 3 lines if they look like standalone dates
            const datePatterns = [
                /\b((?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{1,2},?\s+\d{4})/gi,
                /\b(\d{1,2}\/\d{1,2}\/\d{2,4})/g,
                /\b(\d{1,2}-\d{1,2}-\d{2,4})/g
            ];

            let allDates = [];
            for (const pattern of datePatterns) {
                const matches = cleanedText.matchAll(pattern);
                for (const match of matches) {
                    // Skip if it looks like it's in the name section (first 50 chars)
                    const position = cleanedText.indexOf(match[0]);
                    if (position > 50) {  // Only consider dates after first 50 characters
                        allDates.push(match[1]);
                    }
                }
            }

            // Remove duplicates
            allDates = [...new Set(allDates)];

            // Try to identify birth vs death dates by context
            const birthKeywords = /born|birth/i;
            const deathKeywords = /died|death|passed|departed|entered.*rest|age\s+\d+/i;

            for (const date of allDates) {
                const position = cleanedText.indexOf(date);
                const beforeDate = cleanedText.substring(Math.max(0, position - 50), position);
                const afterDate = cleanedText.substring(position, Math.min(cleanedText.length, position + 50));
                const context = beforeDate + afterDate;

                if (birthKeywords.test(context) && facts.birth_date === 'Not mentioned') {
                    facts.birth_date = date;
                } else if (deathKeywords.test(context) && facts.death_date === 'Not mentioned') {
                    facts.death_date = date;
                }
            }

            // If we couldn't determine by context, assume chronological order
            if (facts.birth_date === 'Not mentioned' && facts.death_date === 'Not mentioned' && allDates.length >= 2) {
                // Sort dates and assume oldest is birth, newest is death
                facts.birth_date = allDates[0];
                facts.death_date = allDates[1];
            } else if (facts.death_date === 'Not mentioned' && allDates.length >= 1) {
                // If only one date, it's probably death date
                facts.death_date = allDates[allDates.length - 1];
            }

            // 4. EXTRACT SPOUSE
            const spousePatterns = [
                /(?:wife|husband|spouse|partner|married\s+to)\s+(?:of|to)?\s*,?\s*([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/i,
                /(?:survived\s+by)\s+(?:his|her)\s+(?:wife|husband|spouse)\s*,?\s*([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/i,
                /(?:beloved|loving|devoted)\s+(?:wife|husband|spouse)\s+(?:of\s+)?([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/i
            ];

            for (const pattern of spousePatterns) {
                const match = cleanedText.match(pattern);
                if (match && match[1] && match[1] !== facts.name) {
                    facts.spouse = match[1].trim();
                    break;
                }
            }

            // 5. EXTRACT CHILDREN
            const childrenPatterns = [
                /(?:children|sons?|daughters?)[:\s,]*([A-Z][^.;]{10,150})/i,
                /survived\s+by[^.]*?(?:children|sons?|daughters?)[:\s,]*([A-Z][^.;]{10,150})/i
            ];

            for (const pattern of childrenPatterns) {
                const match = cleanedText.match(pattern);
                if (match) {
                    let children = match[1].trim();
                    // Clean up - stop at next category
                    children = children.replace(/(?:and|;)\s*(?:grandchildren|siblings?|sisters?|brothers?|nieces?|nephews?).*$/i, '').trim();
                    children = children.replace(/(?:he|she|his|her|their|also|many)\s+(?:is|was|were|are).*$/i, '').trim();
                    if (children.length > 5 && children.length < 200) {
                        facts.children = children;
                        break;
                    }
                }
            }

            // 6. EXTRACT OTHER FAMILY
            const familyPatterns = [
                /(?:grandchildren|grandsons?|granddaughters?)[:\s,]*([A-Z][^.;]{10,150})/i,
                /(?:siblings?|sisters?|brothers?)[:\s,]*([A-Z][^.;]{10,150})/i,
                /(?:nieces?|nephews?)[:\s,]*([A-Z][^.;]{10,150})/i
            ];

            for (const pattern of familyPatterns) {
                const match = cleanedText.match(pattern);
                if (match) {
                    let family = match[1].trim();
                    family = family.replace(/(?:he|she|his|her|their|also|many|and\s+many)\s+(?:is|was|were|are|other).*$/i, '').trim();
                    if (family.length > 5 && family.length < 200) {
                        facts.other_family = family;
                        break;
                    }
                }
            }

            // 7. EXTRACT LOCATION
            const locationPatterns = [
                /(?:of|from|resided?\s+in|lived\s+in)\s+([A-Z][a-z]+(?:,\s*[A-Z]{2})?(?:,\s*[A-Z][a-z]+)?)/i,
                /([A-Z][a-z]+,\s*[A-Z]{2})/,  // City, ST format
                /(?:funeral|service|burial|visitation)\s+(?:at|in|will\s+be\s+held\s+at)\s+([A-Z][^.;]{10,60}?)(?:\.|;|on\s+\d)/i
            ];

            for (const pattern of locationPatterns) {
                const match = cleanedText.match(pattern);
                if (match) {
                    facts.location = match[1].trim();
                    break;
                }
            }

            return facts;
        }

        function updateProgress(percent, message) {
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressText').textContent = message;
        }

        function showResultsList() {
            document.getElementById('detailSection').classList.add('hidden');
            document.getElementById('resultsSection').classList.remove('hidden');

            const list = document.getElementById('resultsList');
            list.innerHTML = '';

            allObituaries.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'result-item';
                div.onclick = () => showDetail(index);

                const name = item.facts?.name || 'Unknown';
                const dates = [item.facts?.birth_date, item.facts?.death_date].filter(d => d && d !== 'Not mentioned').join(' - ') || 'Dates not found';

                div.innerHTML = `
                    <div class="result-thumbnail"><img src="${item.image}" alt="${name}" /></div>
                    <div class="result-info">
                        <div class="result-name">${name}</div>
                        <div class="result-dates">${dates}</div>
                        <div class="result-source" onclick="event.stopPropagation(); viewFullScan('${item.sourceImage}');">
                            üìÑ From: ${item.sourceFilename}
                        </div>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        function showDetail(index) {
            currentDetailIndex = index;
            const item = allObituaries[index];

            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('detailSection').classList.remove('hidden');

            document.getElementById('detailTitle').textContent = `Obituary ${index + 1} of ${allObituaries.length}`;
            document.getElementById('detailImage').src = item.image;
            document.getElementById('detailText').textContent = item.text;

            const factsDiv = document.getElementById('detailFacts');
            factsDiv.innerHTML = '';
            
            const labels = {
                name: 'Name', maiden_name: 'Maiden Name', birth_date: 'Birth Date',
                death_date: 'Death Date', spouse: 'Spouse', children: 'Children',
                other_family: 'Other Family', location: 'Location'
            };

            Object.entries(labels).forEach(([key, label]) => {
                const value = item.facts?.[key] || 'Not mentioned';
                const factItem = document.createElement('div');
                factItem.className = 'fact-item';
                factItem.innerHTML = `<div class="fact-label">${label}</div><div class="fact-value">${value}</div>`;
                factsDiv.appendChild(factItem);
            });

            const sourceItem = document.createElement('div');
            sourceItem.className = 'fact-item';
            sourceItem.innerHTML = `<div class="fact-label">Source Scan</div><div class="fact-value">${item.sourceFilename}</div>`;
            factsDiv.appendChild(sourceItem);

            document.getElementById('prevBtn').disabled = index === 0;
            document.getElementById('nextBtn').disabled = index === allObituaries.length - 1;

            // Auto-search FamilySearch if connected
            if (fsAccessToken && item.facts && item.facts.name !== 'Unknown') {
                setTimeout(() => searchFamilySearch(), 500);
            } else {
                // Hide matches section if not searching
                document.getElementById('fsMatchesSection').classList.add('hidden');
            }
        }

        function previousCard() { if (currentDetailIndex > 0) showDetail(currentDetailIndex - 1); }
        function nextCard() { if (currentDetailIndex < allObituaries.length - 1) showDetail(currentDetailIndex + 1); }
        function backToVerify() {
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('uploadSection').classList.remove('hidden');
        }

        function showFullScan() {
            if (currentDetailIndex < allObituaries.length) {
                viewFullScan(allObituaries[currentDetailIndex].sourceImage);
            }
        }

        function viewFullScan(imageUrl) {
            const modal = document.getElementById('scanModal');
            const modalContent = modal.querySelector('.modal-content');
            const container = document.getElementById('modalImageContainer');
            
            // Reset modal to viewing mode
            modalContent.innerHTML = `
                <span class="close-modal" onclick="closeModal()">&times;</span>
                <div class="modal-controls">
                    <button class="btn btn-secondary" onclick="rotateModalImage()">‚ü≥ Rotate</button>
                    <button class="btn btn-secondary" onclick="zoomModalImage(1.2)">üîç+ Zoom In</button>
                    <button class="btn btn-secondary" onclick="zoomModalImage(0.8)">üîç- Zoom Out</button>
                    <button class="btn btn-secondary" onclick="resetModalImage()">‚Ü∫ Reset</button>
                </div>
                <div class="modal-image-container" id="modalImageContainer">
                    <img id="modalImage" class="modal-image" src="${imageUrl}" alt="Full Scan" />
                </div>
            `;
            
            modalRotation = 0;
            modalZoom = 1;
            modal.classList.add('active');
            
            // Re-setup drag and zoom after DOM update
            setTimeout(() => setupModalInteractions(), 50);
        }

        function setupModalInteractions() {
            const freshContainer = document.getElementById('modalImageContainer');
            const freshImg = document.getElementById('modalImage');
            
            if (!freshContainer || !freshImg) return;

            updateModalTransform();

            // Add drag-to-scroll functionality
            let isDragging = false;
            let startX, startY, scrollLeft, scrollTop;

            freshContainer.addEventListener('mousedown', (e) => {
                if (e.target !== freshContainer && e.target !== freshImg) return;
                isDragging = true;
                freshContainer.classList.add('dragging');
                startX = e.clientX;
                startY = e.clientY;
                scrollLeft = freshContainer.scrollLeft;
                scrollTop = freshContainer.scrollTop;
                e.preventDefault();
            });

            const handleMouseMove = (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                freshContainer.scrollLeft = scrollLeft - dx;
                freshContainer.scrollTop = scrollTop - dy;
            };

            const handleMouseUp = () => {
                isDragging = false;
                freshContainer.classList.remove('dragging');
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Mouse wheel zoom
            freshContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                zoomModalImage(zoomFactor);
            }, { passive: false });
        }

        function updateModalTransform() {
            const img = document.getElementById('modalImage');
            if (img) {
                img.style.transform = `rotate(${modalRotation}deg) scale(${modalZoom})`;
            }
        }

        function closeModal() { document.getElementById('scanModal').classList.remove('active'); }

        function rotateModalImage() {
            modalRotation = (modalRotation + 90) % 360;
            document.getElementById('modalImage').style.transform = `rotate(${modalRotation}deg) scale(${modalZoom})`;
        }

        function zoomModalImage(factor) {
            modalZoom = Math.max(0.5, Math.min(3, modalZoom * factor));
            document.getElementById('modalImage').style.transform = `rotate(${modalRotation}deg) scale(${modalZoom})`;
        }

        function resetModalImage() {
            modalRotation = 0;
            modalZoom = 1;
            document.getElementById('modalImage').style.transform = 'rotate(0deg) scale(1)';
        }

        function clearAllScans() {
            if (confirm('Clear all scans and start over?')) {
                scannedPages = [];
                allObituaries = [];
                document.getElementById('scanRowsContainer').innerHTML = '';
                document.getElementById('verifyControls').classList.add('hidden');
                document.getElementById('clearAllTopBtn').style.display = 'none';
                showStatus('', '');
            }
        }

        function deleteScan(rowId) {
            if (!confirm('Delete this entire scan?')) return;
            
            const pageIndex = parseInt(rowId.replace('scan-row-', ''));
            scannedPages.splice(pageIndex, 1);
            
            // Rebuild all rows
            document.getElementById('scanRowsContainer').innerHTML = '';
            scannedPages.forEach((page, idx) => {
                const newRowId = `scan-row-${idx}`;
                addScanRow(newRowId, page.originalImage, page.filename);
                displaySplits(newRowId, page.splits);
            });
            
            if (scannedPages.length === 0) {
                document.getElementById('verifyControls').classList.add('hidden');
                document.getElementById('clearAllTopBtn').style.display = 'none';
                showStatus('', '');
            } else {
                showStatus(`‚úì ${scannedPages.length} scan(s) remaining`, 'success');
            }
        }

        function deleteSplit(rowId, splitIndex) {
            const pageIndex = parseInt(rowId.replace('scan-row-', ''));
            scannedPages[pageIndex].splits.splice(splitIndex, 1);
            displaySplits(rowId, scannedPages[pageIndex].splits);
        }

        function addManualSelection(rowId) {
            const pageIndex = parseInt(rowId.replace('scan-row-', ''));
            const page = scannedPages[pageIndex];
            
            // Create modal for manual selection
            const modal = document.getElementById('scanModal');
            const modalContent = modal.querySelector('.modal-content');
            
            // Create canvas for selection
            const img = new Image();
            img.onload = () => {
                modalContent.innerHTML = `
                    <span class="close-modal" onclick="closeModal()">&times;</span>
                    <div style="text-align: center; margin-bottom: 20px;">
                        <h2 style="color: var(--text-primary); margin-bottom: 10px;">Select Missing Obituary</h2>
                        <p style="color: var(--text-secondary);">Click and drag to create a selection box around the obituary</p>
                    </div>
                    <div class="selection-canvas-container" id="selectionContainer">
                        <img src="${page.originalImage}" style="display: block; max-width: 100%;" id="selectImg" />
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="closeModal()" style="margin-right: 10px;">Cancel</button>
                        <button class="btn btn-success" onclick="saveManualSelection('${rowId}', ${pageIndex})" id="saveSelectionBtn" disabled>
                            üíæ Save Selection
                        </button>
                    </div>
                `;
                
                modal.classList.add('active');
                
                // Add selection box functionality
                const container = document.getElementById('selectionContainer');
                const selectImg = document.getElementById('selectImg');
                let selectionBox = null;
                let isDrawing = false;
                let startX, startY;
                
                container.addEventListener('mousedown', (e) => {
                    if (e.target !== selectImg) return;
                    
                    const rect = selectImg.getBoundingClientRect();
                    startX = e.clientX - rect.left;
                    startY = e.clientY - rect.top;
                    isDrawing = true;
                    
                    // Remove existing selection box
                    if (selectionBox) selectionBox.remove();
                    
                    // Create new selection box
                    selectionBox = document.createElement('div');
                    selectionBox.className = 'selection-box';
                    selectionBox.style.left = startX + 'px';
                    selectionBox.style.top = startY + 'px';
                    selectionBox.style.width = '0px';
                    selectionBox.style.height = '0px';
                    
                    // Add resize handles
                    ['nw', 'ne', 'sw', 'se'].forEach(pos => {
                        const handle = document.createElement('div');
                        handle.className = `selection-box-handle handle-${pos}`;
                        selectionBox.appendChild(handle);
                    });
                    
                    container.appendChild(selectionBox);
                    document.getElementById('saveSelectionBtn').disabled = false;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDrawing || !selectionBox) return;
                    
                    const rect = selectImg.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;
                    
                    const width = Math.abs(currentX - startX);
                    const height = Math.abs(currentY - startY);
                    const left = Math.min(startX, currentX);
                    const top = Math.min(startY, currentY);
                    
                    selectionBox.style.left = left + 'px';
                    selectionBox.style.top = top + 'px';
                    selectionBox.style.width = width + 'px';
                    selectionBox.style.height = height + 'px';
                });
                
                document.addEventListener('mouseup', () => {
                    isDrawing = false;
                    
                    // Make box draggable and resizable
                    if (selectionBox) {
                        makeBoxDraggable(selectionBox, container, selectImg);
                    }
                });
            };
            img.src = page.originalImage;
        }

        function makeBoxDraggable(box, container, img) {
            let isDragging = false;
            let isResizing = false;
            let resizeHandle = null;
            let startX, startY, startBoxX, startBoxY, startBoxW, startBoxH;
            
            box.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('selection-box-handle')) {
                    isResizing = true;
                    resizeHandle = e.target.className.split(' ')[1].replace('handle-', '');
                } else if (e.target === box) {
                    isDragging = true;
                }
                
                startX = e.clientX;
                startY = e.clientY;
                startBoxX = parseInt(box.style.left);
                startBoxY = parseInt(box.style.top);
                startBoxW = parseInt(box.style.width);
                startBoxH = parseInt(box.style.height);
                e.stopPropagation();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    box.style.left = (startBoxX + dx) + 'px';
                    box.style.top = (startBoxY + dy) + 'px';
                } else if (isResizing) {
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    
                    if (resizeHandle.includes('e')) {
                        box.style.width = Math.max(50, startBoxW + dx) + 'px';
                    }
                    if (resizeHandle.includes('w')) {
                        const newWidth = Math.max(50, startBoxW - dx);
                        box.style.left = (startBoxX + startBoxW - newWidth) + 'px';
                        box.style.width = newWidth + 'px';
                    }
                    if (resizeHandle.includes('s')) {
                        box.style.height = Math.max(50, startBoxH + dy) + 'px';
                    }
                    if (resizeHandle.includes('n')) {
                        const newHeight = Math.max(50, startBoxH - dy);
                        box.style.top = (startBoxY + startBoxH - newHeight) + 'px';
                        box.style.height = newHeight + 'px';
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
                isResizing = false;
            });
        }

        async function saveManualSelection(rowId, pageIndex) {
            const selectionBox = document.querySelector('.selection-box');
            const selectImg = document.getElementById('selectImg');
            
            if (!selectionBox) return;
            
            const imgRect = selectImg.getBoundingClientRect();
            const boxRect = selectionBox.getBoundingClientRect();
            
            // Calculate selection relative to actual image dimensions
            const scaleX = selectImg.naturalWidth / imgRect.width;
            const scaleY = selectImg.naturalHeight / imgRect.height;
            
            const x = (boxRect.left - imgRect.left) * scaleX;
            const y = (boxRect.top - imgRect.top) * scaleY;
            const w = boxRect.width * scaleX;
            const h = boxRect.height * scaleY;
            
            // Extract the selected region
            const img = new Image();
            img.onload = async () => {
                const canvas = document.createElement('canvas');
                canvas.width = w;
                canvas.height = h;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, x, y, w, h, 0, 0, w, h);
                
                const newSplit = {
                    canvas: canvas,
                    dataUrl: canvas.toDataURL('image/jpeg', 0.95),
                    rotated: false,
                    sourcePageIndex: pageIndex
                };
                
                // Auto-rotate the new split
                showStatus('üîÑ Auto-rotating selection...', 'info');
                await autoRotate(newSplit);
                
                // Add to splits
                scannedPages[pageIndex].splits.push(newSplit);
                displaySplits(rowId, scannedPages[pageIndex].splits);
                
                closeModal();
                showStatus('‚úì Manual selection added!', 'success');
            };
            img.src = scannedPages[pageIndex].originalImage;
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            if (!message) { statusDiv.innerHTML = ''; return; }
            statusDiv.innerHTML = `<div class="status-message ${type}">${message}</div>`;
        }

        function rotateModalImage() {
            modalRotation = (modalRotation + 90) % 360;
            updateModalTransform();
        }

        function zoomModalImage(factor) {
            modalZoom = Math.max(0.5, Math.min(5, modalZoom * factor));
            updateModalTransform();
        }

        function resetModalImage() {
            modalRotation = 0;
            modalZoom = 1;
            updateModalTransform();
        }


        // ============================================================================
        // FAMILYSEARCH API INTEGRATION
        // ============================================================================

        // Check for OAuth callback on page load
        (function() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            
            if (code) {
                // Exchange code for token
                exchangeCodeForToken(code);
            } else {
                // Check if we have a stored token
                const storedToken = localStorage.getItem('fs_access_token');
                if (storedToken) {
                    fsAccessToken = storedToken;
                    updateFSLoginUI(true);
                }
            }
        })();

        function loginToFamilySearch() {
            if (FS_APP_KEY === 'YOUR_APP_KEY_HERE') {
                alert('FamilySearch App Key not configured.\n\n' +
                      'To enable FamilySearch integration:\n' +
                      '1. Register your app at https://www.familysearch.org/developers/\n' +
                      '2. Get your App Key\n' +
                      '3. Replace FS_APP_KEY in the code');
                return;
            }

            const authUrl = `https://ident.familysearch.org/cis-web/oauth2/v3/authorization?` +
                `response_type=code` +
                `&client_id=${FS_APP_KEY}` +
                `&redirect_uri=${encodeURIComponent(FS_REDIRECT_URI)}`;
            
            window.location.href = authUrl;
        }

        async function exchangeCodeForToken(code) {
            try {
                // Note: In production, this should go through a backend to keep client_secret secure
                // For now, we'll use the code directly (FamilySearch allows this for testing)
                
                showStatus('üîê Connecting to FamilySearch...', 'info');
                
                const response = await fetch('https://ident.familysearch.org/cis-web/oauth2/v3/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: `grant_type=authorization_code&code=${code}&client_id=${FS_APP_KEY}&redirect_uri=${encodeURIComponent(FS_REDIRECT_URI)}`
                });

                const data = await response.json();
                
                if (data.access_token) {
                    fsAccessToken = data.access_token;
                    localStorage.setItem('fs_access_token', fsAccessToken);
                    updateFSLoginUI(true);
                    showStatus('‚úì Connected to FamilySearch!', 'success');
                    
                    // Clean up URL
                    window.history.replaceState({}, document.title, FS_REDIRECT_URI);
                } else {
                    throw new Error('No access token received');
                }
            } catch (error) {
                console.error('FamilySearch auth error:', error);
                showStatus('‚ö† Failed to connect to FamilySearch', 'warning');
            }
        }

        function logoutFromFamilySearch() {
            fsAccessToken = null;
            localStorage.removeItem('fs_access_token');
            updateFSLoginUI(false);
            showStatus('Disconnected from FamilySearch', 'info');
        }

        function updateFSLoginUI(loggedIn) {
            const section = document.getElementById('fsLoginSection');
            const status = document.getElementById('fsStatus');
            const loginBtn = document.getElementById('fsLoginBtn');
            const logoutBtn = document.getElementById('fsLogoutBtn');

            if (loggedIn) {
                section.classList.add('logged-in');
                status.textContent = '‚úì Connected to FamilySearch';
                loginBtn.style.display = 'none';
                logoutBtn.style.display = 'inline-block';
            } else {
                section.classList.remove('logged-in');
                status.textContent = 'Not connected to FamilySearch';
                loginBtn.style.display = 'inline-block';
                logoutBtn.style.display = 'none';
            }
        }

        async function searchFamilySearch() {
            if (!fsAccessToken) {
                alert('Please connect to FamilySearch first');
                return;
            }

            const item = allObituaries[currentDetailIndex];
            const facts = item.facts;

            if (!facts || facts.name === 'Unknown') {
                alert('No name found in obituary to search');
                return;
            }

            showStatus('üîç Searching FamilySearch...', 'info');

            try {
                // Build search query
                const params = new URLSearchParams();
                params.append('q.givenName', facts.name.split(' ')[0] || '');
                params.append('q.surname', facts.name.split(' ').slice(-1)[0] || '');
                
                if (facts.birth_date && facts.birth_date !== 'Not mentioned') {
                    // Try to extract year
                    const yearMatch = facts.birth_date.match(/\d{4}/);
                    if (yearMatch) {
                        params.append('q.birthLikeDate', yearMatch[0]);
                    }
                }
                
                if (facts.death_date && facts.death_date !== 'Not mentioned') {
                    const yearMatch = facts.death_date.match(/\d{4}/);
                    if (yearMatch) {
                        params.append('q.deathLikeDate', yearMatch[0]);
                    }
                }

                const response = await fetch(
                    `https://api.familysearch.org/platform/tree/search?${params.toString()}`,
                    {
                        headers: {
                            'Authorization': `Bearer ${fsAccessToken}`,
                            'Accept': 'application/json'
                        }
                    }
                );

                if (!response.ok) {
                    if (response.status === 401) {
                        // Token expired
                        logoutFromFamilySearch();
                        alert('Session expired. Please reconnect to FamilySearch.');
                        return;
                    }
                    throw new Error(`Search failed: ${response.status}`);
                }

                const data = await response.json();
                fsCurrentMatches = data.entries || [];
                
                displayFSMatches();
                showStatus(`‚úì Found ${fsCurrentMatches.length} potential match(es)`, 'success');

            } catch (error) {
                console.error('FamilySearch search error:', error);
                showStatus('‚ö† Search failed. Check console for details.', 'warning');
            }
        }

        function displayFSMatches() {
            const section = document.getElementById('fsMatchesSection');
            const list = document.getElementById('fsMatchesList');
            
            section.classList.remove('hidden');
            list.innerHTML = '';

            if (fsCurrentMatches.length === 0) {
                list.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">No matches found. Try adjusting the extracted facts or search manually on FamilySearch.org</p>';
                return;
            }

            fsCurrentMatches.slice(0, 10).forEach(entry => {
                const person = entry.content?.gedcomx?.persons?.[0];
                if (!person) return;

                const personId = person.id;
                const name = person.display?.name || 'Unknown';
                const lifespan = person.display?.lifespan || '';
                const gender = person.display?.gender || '';

                const matchDiv = document.createElement('div');
                matchDiv.className = 'fs-match-item';
                matchDiv.innerHTML = `
                    <div class="fs-match-info">
                        <div class="fs-match-name">${name}</div>
                        <div class="fs-match-details">
                            ${lifespan ? `üìÖ ${lifespan}` : ''} 
                            ${gender ? `‚Ä¢ ${gender}` : ''}
                            ${personId ? `‚Ä¢ ID: ${personId}` : ''}
                        </div>
                    </div>
                    <div class="fs-match-actions">
                        <button class="btn btn-secondary" onclick="copyPersonId('${personId}')" style="padding: 6px 12px; font-size: 0.85rem;">
                            üìã Copy ID
                        </button>
                        <button class="btn btn-primary" onclick="openFSPerson('${personId}')" style="padding: 6px 12px; font-size: 0.85rem;">
                            üå≥ Open in FamilySearch
                        </button>
                    </div>
                `;
                list.appendChild(matchDiv);
            });
        }

        function copyPersonId(personId) {
            navigator.clipboard.writeText(personId).then(() => {
                showStatus(`‚úì Copied Person ID: ${personId}`, 'success');
                setTimeout(() => showStatus('', ''), 2000);
            }).catch(err => {
                console.error('Copy failed:', err);
                alert(`Person ID: ${personId}\n(Copy failed, please copy manually)`);
            });
        }

        function openFSPerson(personId) {
            window.open(`https://www.familysearch.org/tree/person/details/${personId}`, '_blank');
        }
    </script>
</body>
</html>
